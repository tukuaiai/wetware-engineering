\documentclass{article}

\usepackage{arxiv}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{url}
\usepackage{booktabs}
\usepackage{amsfonts}
\usepackage{microtype}
\usepackage{graphicx}
\usepackage{natbib}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{float}

% Code listing style with syntax highlighting
\lstset{
  basicstyle=\ttfamily\footnotesize,
  breaklines=true,
  frame=single,
  backgroundcolor=\color{gray!5},
  xleftmargin=0.5em,
  aboveskip=0.5em,
  belowskip=0.5em,
  keywordstyle=\bfseries\color{blue!70!black},
  commentstyle=\color{green!50!black},
  stringstyle=\color{orange!80!black},
  morekeywords={COMPONENT,CONNECT,RUNTIME,FROM,TO,VIA,WITH,ON,DO,WHEN,THEN,EVERY,TEST,GIVEN,EXPECT,ADAPTER,SET,WAIT,LOG,RUN,IF,REDUCE,INCREASE,BY,STIMULATE,AT,FOR,IN,WITHIN,AND,AS,RECORD,ACTIVATE,SIMULTANEOUSLY},
}

\title{Wetware Engineering: Applying Software Engineering Paradigms to Biological System Construction}

\author{
  \href{https://orcid.org/0009-0009-6523-1823}{\includegraphics[scale=0.06]{orcid.pdf}\hspace{1mm}123olp} \\
  Independent Researcher \\
  \texttt{tukuai.ai@gmail.com}
}

\date{December 2025}

\renewcommand{\shorttitle}{Wetware Engineering}

%%% PDF Metadata
\hypersetup{
  pdftitle={Wetware Engineering: Applying Software Engineering Paradigms to Biological System Construction},
  pdfauthor={123olp},
  pdfsubject={A cross-disciplinary methodology that transfers software engineering abstractions to biological system construction, proposing Bio-Component Spec and Bio-DSL for modular life systems.},
  pdfkeywords={Software Engineering, Biological Systems, Synthetic Biology, Modular Design, Domain-Specific Language, Systems Biology, Tissue Engineering, Biohybrid Systems, Component-Based Design, Interface Standardization},
  pdfcreator={XeLaTeX with arxiv-style template},
  pdfproducer={Wetware Engineering Project},
  pdflang={en-US},
}

\begin{document}
\maketitle

\begin{abstract}
Software engineering underwent a paradigm shift from monolithic programs to modular, composable systems over five decades---enabled by standardized interfaces, package managers, version control, and runtime orchestration. Biological engineering remains in an analogous ``pre-modular'' era: each system is constructed from scratch, results are difficult to reproduce, and no universal language exists for describing biological component composition.

We propose \textbf{Wetware Engineering}, a cross-disciplinary methodology that transfers software engineering's core abstractions---modularity, interface standardization, dependency management, and runtime orchestration---to biological system construction. Our contributions include: (1) the \textbf{Component-Interface-Runtime triad} as foundational abstraction for modular biological systems; (2) \textbf{Bio-Component Spec}, a standardized schema for describing biological modules; (3) \textbf{Bio-DSL}, a domain-specific language for declarative system composition; and (4) systematic analysis identifying both direct translations and fundamental differences requiring novel solutions.

Wetware Engineering represents a paradigm-level contribution: shifting biological system construction from ``artisanal replication'' to ``engineered composition.''
\end{abstract}

\keywords{Software Engineering, Biological Systems, Modular Design, Domain-Specific Language, Systems Biology}

\section{Introduction: The Case for Paradigm Transfer}

\subsection{Software Engineering's Modular Revolution}

The history of software engineering is fundamentally a history of rising abstraction levels. In the 1950s, programmers wrote machine code. Assembly language provided the first abstraction. Structured programming (1960s) abstracted control flow. Object-oriented programming (1980s) encapsulated data and behavior. Component-based development (1990s) enabled binary-level reuse. Service-oriented architecture (2000s) abstracted deployment. Microservices (2010s) achieved independent deployment and elastic scaling.

Each abstraction level did not merely add convenience---it fundamentally changed what was possible. Before package managers, sharing code meant copying files. Before containerization, ``it works on my machine'' was unsolvable. Before version control, collaboration meant emailing zip files.

Today, a developer can declare \texttt{import tensorflow} and instantly access millions of lines of tested, documented, version-controlled code---the accumulated result of decades of standardization.

\subsection{Biological Engineering's ``Pre-Modular'' State}

Biological engineering in 2025, despite extraordinary advances, remains analogous to software circa 1970:

\begin{table}[H]
\centering
\caption{Software vs. Biological Engineering: Current State}
\begin{tabular}{@{}lll@{}}
\toprule
Software Concept & Biology Status & The Gap \\
\midrule
Standard Library & None & Each lab builds from scratch \\
Package Manager & None & Cannot declare dependencies \\
Version Control & None & ``This batch differs from last'' \\
API Documentation & None & ``Ask the original author'' \\
Unit Testing & None & ``How long will it last?'' \\
\bottomrule
\end{tabular}
\end{table}

When a tissue engineer wants to combine a muscle actuator with a neural controller, they face challenges software engineers solved decades ago: no standard interfaces, no dependency declaration, no version compatibility, no composition language.

The fundamental problem is conceptual: biological systems are treated as \textbf{indivisible wholes} rather than \textbf{composable collections of modules}.

\subsection{Why Paradigm Transfer, Not Just Tool Application}

Existing ``computational biology'' means using computers to analyze data (bioinformatics), simulate processes (systems biology), or control experiments (automation). These apply software as a \textit{tool} to biology.

We propose something different: \textbf{using software engineering's design philosophy to reconceptualize how biological systems are constructed}. This is paradigm transfer, not tool application.

\subsection{Contributions}

\begin{enumerate}
\item \textbf{Paradigm Definition}: Systematic transfer of software engineering paradigms to biological system construction
\item \textbf{Abstraction Framework}: Component-Interface-Runtime triad for modular biological systems
\item \textbf{Technical Specifications}: Bio-Component Spec v0.1 and Bio-DSL
\item \textbf{Mapping Analysis}: Direct, Analogous, and Novel mappings identified
\item \textbf{Difference Identification}: Fundamental challenges requiring innovation
\end{enumerate}


\section{Core Abstractions: The Component-Interface-Runtime Triad}

\subsection{Abstraction as the Essence of Engineering}

Dijkstra observed: ``The purpose of abstraction is not to be vague, but to create a new semantic level in which one can be absolutely precise.'' Software engineering's success stems from identifying correct abstraction boundaries: functions abstract instructions, objects abstract data and behavior, interfaces abstract implementations, containers abstract environments.

The central question for biological engineering: \textbf{What are the correct abstraction boundaries for living systems?}

We propose the same triad that revolutionized software: \textbf{Component}, \textbf{Interface}, and \textbf{Runtime}.

\subsection{Component: The Unit of Biological Reuse}

A \textbf{Bio-Component} is a biological unit that: can exist independently (with life support), can receive energy/nutrients, can respond to control signals, can produce functional outputs, and can report its state.

\begin{table}[H]
\centering
\caption{Component Typology}
\begin{tabular}{@{}lll@{}}
\toprule
Type & Software Analogy & Biological Examples \\
\midrule
Actuator & Output driver & Muscle, gland \\
Sensor & Input driver & Photoreceptor, mechanoreceptor \\
Processor & CPU/logic & Ganglion, brain organoid \\
Storage & Memory/database & Adipose tissue \\
Connector & Network interface & Blood vessel, nerve \\
Metabolic & Power supply & Liver tissue \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Interface: The Contract for Composition}

The Gang of Four principle: ``Program to an interface, not an implementation.'' Biological interfaces operate across four dimensions:

\textbf{Power Interface}: Energy and nutrient flow (perfusion connections, diffusion surfaces)

\textbf{Signal Interface}: Information exchange (electrical, chemical, mechanical, optical)

\textbf{Isolation Interface}: Protection barriers (immune, toxicity, electrical isolation)

\textbf{Mechanical Interface}: Force transmission (structural attachments, movement coupling)

The USB analogy: before USB, every device had proprietary connectors. After USB, one connector fits all. We envision Bio-Interfaces achieving similar transformation.

\subsection{Runtime: The Orchestration Layer}

A Bio-Runtime handles: nutrient allocation (memory), activity timing (CPU scheduling), signal routing (network I/O), viability monitoring (health checks), regeneration triggering (auto-restart), biomarker recording (logging), and fault isolation (containing necrosis).

The perfusion system---delivering nutrients and oxygen while removing waste---is the biological equivalent of power and network infrastructure.

\subsection{The Triad in Action}

A simple bio-robotic system (muscle responding to force) in Bio-DSL:
\begin{lstlisting}
CONNECT sensor.output TO controller.input
CONNECT controller.output TO muscle.stimulation
RUNTIME { perfusion: standard_mammalian, control: closed_loop }
\end{lstlisting}

The same description works with different implementations (human/mouse/synthetic muscle, piezoelectric/biological sensor) as long as interfaces are honored.

\section{Systematic Mapping: Software to Biological Engineering}

\subsection{Mapping Framework}

We categorize mappings as:
\begin{itemize}
\item \textbf{Direct}: Transfers with minimal adaptation (versioning, dependencies, docs)
\item \textbf{Analogous}: Core idea transfers but requires adaptation (testing, error handling)
\item \textbf{Novel}: No software equivalent; requires new solutions (immune, degradation)
\end{itemize}

\subsection{Direct Mappings}

\textbf{Semantic Versioning}: MAJOR.MINOR.PATCH transfers directly. Example: \texttt{muscle-actuator@2.3.1} where MAJOR=interface-breaking, MINOR=backward-compatible additions, PATCH=fixes.

\textbf{Dependency Declaration}: Package manifests work identically:
\begin{lstlisting}
dependencies:
  perfusion-medium: "DMEM@^1.0"
  oxygen-supply: ">=15%"
\end{lstlisting}

\textbf{Documentation and Licensing}: README files, API docs, and license frameworks transfer directly.

\subsection{Analogous Mappings}

\textbf{Testing → Validation}: Software tests are deterministic and fast; biological tests are statistical and slow. Adaptation: define acceptance criteria as statistical thresholds.

\textbf{Error Handling → Failure Mode Management}: Software has exceptions/errors/warnings; biology has recoverable degradation (fatigue), irreversible damage (necrosis), and systemic risk (inflammation).

\textbf{Logging → Biomarker Recording}: Timestamps, measurements, environmental conditions, anomaly indicators.

\subsection{Novel Challenges}

\textbf{Immune Compatibility}: Software components don't ``reject'' each other. Required: compatibility scoring, isolation barriers.

\textbf{Signal Crosstalk}: Software processes are isolated; biological components share chemical environments.

\textbf{Metabolic Coupling}: Software components consume resources independently; biological components share metabolites and produce waste affecting neighbors.

\textbf{Living Degradation}: Software doesn't age; biological components inherently degrade.

\textbf{Ethical Constraints}: Software has no ethical status; biological components raise consent, capability, and disposal considerations.


\section{Bio-Component Specification}

\subsection{Design Principles}

Bio-Component Spec draws from software engineering principles:

\textbf{SOLID Applied}: Single Responsibility (one biological function), Open/Closed (enhance without changing interfaces), Liskov Substitution (compatible components interchangeable), Interface Segregation (fine-grained definitions), Dependency Inversion (depend on specs, not implementations).

\textbf{Convention over Configuration}: Sensible defaults minimize required configuration.

\textbf{Schema-First Design}: Define schema before implementations, like OpenAPI for REST APIs.

\subsection{Specification Structure}

The complete schema (Appendix~\ref{app:schema}) includes:
\begin{itemize}
\item \textbf{Identification}: id, name, version, license, authors
\item \textbf{Classification}: type (actuator/sensor/processor/...), domain, tags
\item \textbf{Source}: organism, tissue type, cell types, biosafety level
\item \textbf{Interface}: input/output port definitions with parameters
\item \textbf{Requirements}: physical (temperature), chemical (pH, oxygen), biological
\item \textbf{Performance}: functional metrics, reliability, resource consumption
\item \textbf{Failure Modes}: detection, type (recoverable/irreversible), mitigation
\item \textbf{Testing}: unit tests, integration tests
\item \textbf{Dependencies}: components, adapters, protocols
\end{itemize}

\subsection{Versioning Strategy}

Semantic versioning with biological interpretations:
\begin{itemize}
\item \textbf{MAJOR}: Interface-breaking (port type changes, new required parameters)
\item \textbf{MINOR}: Backward-compatible (new optional ports, performance improvements)
\item \textbf{PATCH}: Fixes (protocol optimizations, documentation)
\end{itemize}

Extended format for biological specificity: \texttt{2.3.1+batch20251228.donor42.wildtype}

A complete muscle actuator specification is provided in Appendix~\ref{app:muscle}.

\section{Bio-DSL: Language Design}

\subsection{Why a Domain-Specific Language?}

DSLs trade generality for expressiveness. Benefits for biological systems:
\begin{itemize}
\item \textbf{Expressiveness}: Describe complex assemblies concisely
\item \textbf{Readability}: Biologists can understand without programming background
\item \textbf{Validation}: Catch interface mismatches before physical assembly
\item \textbf{Abstraction}: Focus on what, not how
\end{itemize}

\subsection{Design Goals}

\begin{enumerate}
\item \textbf{Declarative}: Describe \textit{what} the system is, not \textit{how} to build it
\item \textbf{Readable}: Biologists should understand the intent
\item \textbf{Verifiable}: Static analysis catches errors before assembly
\item \textbf{Executable}: Generates runtime configurations
\item \textbf{Composable}: Systems can be nested and reused
\end{enumerate}

\subsection{Language Constructs}

\textbf{Component Declaration}:
\begin{lstlisting}
COMPONENT flexor FROM "muscle-actuator@^2.3"
COMPONENT sensor FROM "piezo-sensor@~1.1" AS force_sensor
\end{lstlisting}

\textbf{Connection Declaration}:
\begin{lstlisting}
CONNECT sensor.output TO controller.input
CONNECT controller.output TO muscle.stim VIA adapter
\end{lstlisting}

\textbf{Runtime Configuration}:
\begin{lstlisting}
RUNTIME {
  perfusion: { temp: 37~C, pH: 7.4 },
  control: { mode: "closed_loop" }
}
\end{lstlisting}

\textbf{Behavioral Logic}:
\begin{lstlisting}
ON STARTUP DO { SET perfusion.flow = 0.5; WAIT 300s }
WHEN fatigue > 0.3 THEN { REDUCE freq BY 20% }
\end{lstlisting}

\textbf{Test Declaration}:
\begin{lstlisting}
TEST response {
  GIVEN muscle.state == "ready"
  WHEN STIMULATE AT 10Hz FOR 1s
  THEN EXPECT force IN [5,15] mN
}
\end{lstlisting}

\subsection{Relationship to Existing Languages}

Bio-DSL complements lower-level languages:
\begin{itemize}
\item \textbf{SBOL}: Genetic level (DNA sequences)---component internals
\item \textbf{SBML}: Molecular level (biochemical networks)---component dynamics
\item \textbf{CellML}: Cellular level (mathematical models)---behavior models
\item \textbf{Bio-DSL}: Organ/System level---component composition
\end{itemize}

A complete dual-muscle antagonist system example is provided in Appendix~\ref{app:example}.


\section{Fundamental Differences and Open Challenges}

While paradigm transfer is powerful, fundamental differences require novel solutions:

\subsection{Determinism vs. Stochasticity}

Software: \texttt{add(2,3)} always returns 5. Biology: identical stimulation produces variable force, occasionally no response.

\textbf{Implications}: Probabilistic interface contracts, statistical testing, redundant components, graceful degradation.

\subsection{Discrete vs. Continuous}

Software state transitions are instantaneous (true/false). Biological transitions are gradual (relaxed → contracting → contracted).

\textbf{Implications}: Tolerance ranges for parameters, threshold-based state definitions, range-based timing specifications.

\subsection{Isolation vs. Coupling}

Software processes are isolated by OS memory protection. Biological components share culture medium; one component's waste affects all others.

\textbf{Implications}: Explicit coupling declarations, isolation adapters, system-level resource budgeting.

\subsection{The Immune System}

Software components don't ``reject'' each other. Biological components from different genetic backgrounds trigger immune responses.

\textbf{Required Innovations}: Immune compatibility scoring, isolation barrier specifications, compatibility checking in Bio-DSL.

\subsection{Living Degradation}

Software doesn't age. Biological components inherently degrade: cells senesce, proteins denature, structures weaken.

\textbf{Required Innovations}: Degradation modeling (Weibull distribution), maintenance protocols, hot-swap replacement strategies.

\subsection{Ethical Constraints}

Software has no ethical status. Biological components raise considerations: source ethics (consent), capability ethics (consciousness), use ethics (applications), disposal ethics.

\textbf{Required Innovations}: Ethical metadata in specifications, capability limits enforced by compiler.

\subsection{Summary: Innovation Agenda}

\begin{table}[H]
\centering
\caption{Challenges Requiring Innovation}
\begin{tabular}{@{}lll@{}}
\toprule
Challenge & Software & Required Innovation \\
\midrule
Stochasticity & Deterministic & Probabilistic contracts \\
Continuous & Discrete & Tolerance ranges \\
Coupling & Isolated & Resource budgeting \\
Immune & None & Compatibility scoring \\
Degradation & None & Maintenance protocols \\
Ethics & Licensing & Capability limits \\
\bottomrule
\end{tabular}
\end{table}

These challenges define the research agenda, not invalidate the paradigm transfer.

\section{Related Work and Positioning}

\subsection{Synthetic Biology}

BioBricks/iGEM pioneered standardization at the genetic level. SBOL provides data formats for genetic designs.

\textbf{Relationship}: BioBricks/SBOL operate at genetic level; Wetware Engineering at organ/system level. Complementary: BioBricks defines genetic content \textit{within} Bio-Components.

\subsection{Organ-on-Chip and Organoids}

Organ-on-chip devices culture cells in microfluidic environments. Organoids are self-organizing 3D tissue cultures.

\textbf{Relationship}: These provide physical implementations but lack standardized interfaces. Wetware Engineering provides the abstraction framework.

\subsection{Systems Biology Modeling}

SBML/CellML describe how components behave internally (simulation).

\textbf{Relationship}: Bio-DSL describes how components connect externally (composition). Different purposes, can be used together.

\subsection{Biohybrid Robotics}

Research groups have created muscle-powered swimmers, biohybrid grippers. These prove feasibility.

\textbf{Relationship}: Current work is bespoke. Wetware Engineering provides systematic, reproducible methodology.

\subsection{What We Are NOT Claiming}

\begin{enumerate}
\item We have not built working systems (framework proposal)
\item Biology is not ``just like'' software (Section 6 details differences)
\item We don't replace existing approaches (we complement them)
\item This is not immediately practical (roadmap spans decades)
\end{enumerate}

\textbf{What we claim}: Software engineering's conceptual framework provides valuable abstractions for biological system construction.


\section{Conclusion and Future Directions}

\subsection{Summary of Contributions}

This paper proposed \textbf{Wetware Engineering}, transferring software engineering paradigms to biological system construction:

\begin{itemize}
\item \textbf{Conceptual Framework}: Component-Interface-Runtime triad
\item \textbf{Technical Specifications}: Bio-Component Spec v0.1, Bio-DSL
\item \textbf{Systematic Analysis}: Direct, Analogous, Novel mappings
\item \textbf{Honest Assessment}: Fundamental differences requiring innovation
\end{itemize}

\subsection{The Path Forward}

\textbf{Phase 1 (1-3 years)}: Refine specifications, proof-of-concept tooling, document existing systems, reference implementations.

\textbf{Phase 2 (3-7 years)}: Physical implementations, reproducibility validation, interface adapters, component registry.

\textbf{Phase 3 (7-15 years)}: Community governance, commercial adoption, educational curriculum, international standardization.

\subsection{Call to Action}

\textbf{Biologists}: Describe work using Bio-Component Spec; identify interface requirements; share machine-readable protocols.

\textbf{Software Engineers}: Contribute tooling; apply design patterns; develop testing frameworks.

\textbf{Standards Bodies}: Engage early; coordinate with SBOL/SBML.

\textbf{Funding Agencies}: Support cross-disciplinary methodology; fund infrastructure.

\subsection{Closing Thoughts}

Software engineering transformed from craft to discipline over five decades through conceptual breakthroughs, standardization, tooling, and community building.

Biological engineering stands at a similar inflection point. The question is not whether modularization will come---complexity demands it---but how quickly and how well.

The tools of software engineering---abstraction, modularity, standardization, composition---are not specific to silicon. They are \textbf{general principles of managing complexity}. Biology is complex. These principles can help.

The future of biological engineering is modular. Will we design that future deliberately, or stumble into it accidentally?

We choose to design.

\section*{Data Availability}
All specifications and examples: \url{https://github.com/tukuaiai/wetware-engineering}

%==============================================================================
% REFERENCES
%==============================================================================
\bibliographystyle{unsrtnat}
\begin{thebibliography}{15}

\bibitem{parnas1972} Parnas, D.L. (1972). On the criteria to be used in decomposing systems into modules. \textit{Communications of the ACM}, 15(12), 1053--1058.

\bibitem{dijkstra1968} Dijkstra, E.W. (1968). Go to statement considered harmful. \textit{Communications of the ACM}, 11(3), 147--148.

\bibitem{gamma1994} Gamma, E., Helm, R., Johnson, R., \& Vlissides, J. (1994). \textit{Design Patterns: Elements of Reusable Object-Oriented Software}. Addison-Wesley.

\bibitem{fowler2010} Fowler, M. (2010). \textit{Domain-Specific Languages}. Addison-Wesley.

\bibitem{endy2005} Endy, D. (2005). Foundations for engineering biology. \textit{Nature}, 438(7067), 449--453.

\bibitem{galdzicki2014} Galdzicki, M., et al. (2014). The Synthetic Biology Open Language (SBOL) provides a community standard for communicating designs in synthetic biology. \textit{Nature Biotechnology}, 32(6), 545--550.

\bibitem{lancaster2014} Lancaster, M.A., \& Knoblich, J.A. (2014). Organogenesis in a dish: Modeling development and disease using organoid technologies. \textit{Science}, 345(6194), 1247125.

\bibitem{bhatia2014} Bhatia, S.N., \& Ingber, D.E. (2014). Microfluidic organs-on-chips. \textit{Nature Biotechnology}, 32(8), 760--772.

\bibitem{hucka2003} Hucka, M., et al. (2003). The systems biology markup language (SBML): A medium for representation and exchange of biochemical network models. \textit{Bioinformatics}, 19(4), 524--531.

\bibitem{lloyd2004} Lloyd, C.M., Halstead, M.D., \& Nielsen, P.F. (2004). CellML: Its future, present and past. \textit{Progress in Biophysics and Molecular Biology}, 85(2--3), 433--450.

\bibitem{raman2017} Raman, R., \& Bashir, R. (2017). Biomimicry, biofabrication, and biohybrid systems: The emergence and evolution of biological design. \textit{Advanced Healthcare Materials}, 6(20), 1700496.

\bibitem{ricotti2017} Ricotti, L., et al. (2017). Biohybrid actuators for robotics: A review of devices actuated by living cells. \textit{Science Robotics}, 2(12), eaaq0495.

\bibitem{park2016} Park, S.J., et al. (2016). Phototactic guidance of a tissue-engineered soft-robotic ray. \textit{Science}, 353(6295), 158--162.

\bibitem{yuste2017} Yuste, R., et al. (2017). Four ethical priorities for neurotechnologies and AI. \textit{Nature}, 551(7679), 159--163.

\bibitem{hyun2020} Hyun, I., Scharf-Deering, J.C., \& Lunshof, J.E. (2020). Ethical issues related to brain organoid research. \textit{Brain Research}, 1732, 146653.

\end{thebibliography}


%==============================================================================
% APPENDICES
%==============================================================================
\appendix

\section{Complete Bio-DSL Example: Dual-Muscle Antagonist System}
\label{app:example}

\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
// ============================================
// Bio-Mechanical Arm Unit v0.1
// Dual-muscle antagonist with closed-loop control
// ============================================

// === Component Declarations ===
COMPONENT flexor FROM "muscle-actuator-human-skeletal@^2.3" {
  role: "agonist",
  force_range: [0, 50] mN
}

COMPONENT extensor FROM "muscle-actuator-human-skeletal@^2.3" {
  role: "antagonist", 
  force_range: [0, 50] mN
}

COMPONENT sensor FROM "piezo-force-sensor@~1.1" {
  range: [0, 100] mN,
  sampling_rate: 100,Hz
}

COMPONENT controller FROM "neural-organoid-spinal@>=0.8" {
  input_channels: 2,
  output_channels: 2
}

// === Adapter Declarations ===
ADAPTER perfusion FROM "microfluidic-4ch@1.0" {
  medium: "DMEM + 10% FBS",
  flow_rate: 0.5,mL/min PER channel
}

ADAPTER stim_converter FROM "opto-electrical@2.0" {
  wavelength: 470,nm
}

// === Connection Topology ===
CONNECT controller.output_1 TO flexor.stimulation 
  VIA stim_converter
  WITH { frequency: [1, 50] Hz, voltage: [0, 3] V }

CONNECT controller.output_2 TO extensor.stimulation
  VIA stim_converter
  WITH { frequency: [1, 50] Hz, voltage: [0, 3] V }

CONNECT sensor.output TO controller.feedback_input
  WITH { gain: 1.5 }

CONNECT perfusion.ch1 TO flexor.perfusion_input
CONNECT perfusion.ch2 TO extensor.perfusion_input
CONNECT perfusion.ch3 TO controller.perfusion_input
CONNECT perfusion.ch4 TO sensor.perfusion_input

// === Runtime Configuration ===
RUNTIME {
  perfusion: {
    temperature: 37~C,
    pH: 7.4,
    oxygenation: true,
    waste_removal: "continuous"
  },
  
  control: {
    mode: "closed_loop",
    target: "position",
    pid: { Kp: 0.8, Ki: 0.2, Kd: 0.1 }
  },
  
  monitoring: {
    interval: 10 s,
    metrics: [
      "flexor.force", "extensor.force",
      "sensor.reading", "controller.activity",
      "*.viability"
    ],
    alerts: {
      "viability < 80%": "WARNING",
      "force > 90,mN": "CRITICAL"
    }
  },
  
  safety: {
    max_force: 100,mN,
    emergency: {
      trigger: "viability < 50% OR force > 120,mN",
      action: "STOP_ALL; PERFUSION_ONLY"
    }
  }
}

// === Behavioral Logic ===
ON STARTUP DO {
  SET perfusion.flow_rate = 0.5,mL/min
  WAIT 300,s  // Equilibration period
  RUN calibration_sequence()
  SET controller.mode = "active"
  LOG "System initialized"
}

WHEN target_position CHANGES THEN {
  error = target_position - sensor.reading
  controller.compute(error)
}

WHEN flexor.fatigue_index > 0.3 THEN {
  LOG "Flexor fatigue detected"
  REDUCE flexor.stim_frequency BY 20%
  INCREASE extensor.stim_frequency BY 10%
}

EVERY 1 hour DO {
  RUN viability_check()
  RECORD performance_snapshot()
}

// === Test Suite ===
TEST unit_response {
  description: "Single muscle contraction test"
  GIVEN flexor.state == "ready"
  WHEN STIMULATE flexor AT 10,Hz, 2 V FOR 1 s
  THEN EXPECT flexor.force IN [5, 15] mN WITHIN 200,ms
}

TEST antagonist_balance {
  description: "Antagonist coordination test"
  GIVEN system.mode == "active"
  WHEN ACTIVATE flexor AND extensor SIMULTANEOUSLY
  THEN EXPECT |flexor.force - extensor.force| < 5,mN
}

TEST tracking_accuracy {
  description: "Closed-loop tracking test"
  GIVEN system.mode == "closed_loop"
  WHEN SET target = sine_wave(0.5 Hz, +/-20 mN) FOR 60 s
  THEN EXPECT tracking_error < 3 mN RMS
}

// === Expected Performance ===
EXPECTED {
  position_accuracy: +/-2 mN,
  bandwidth: [0, 2] Hz,
  lifetime: [7, 14] days,
  power_consumption: [50, 100] mW
}
\end{lstlisting}

\section{Complete Muscle Actuator Specification}
\label{app:muscle}

\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
bio-component: "1.0"

info:
  id: "muscle-actuator-human-skeletal"
  name: "Human Skeletal Muscle Actuator"
  version: "2.3.1"
  description: "Contractile muscle tissue for force generation"
  license: "CC-BY-SA-4.0"
  authors: ["Wetware Engineering Project"]
  repository: "https://github.com/wetware/muscle-actuator"

classification:
  type: "actuator"
  domain: "musculoskeletal"
  tags: ["muscle", "contractile", "force-generation", "human"]

source:
  organism: "Homo sapiens"
  tissue_type: "skeletal muscle"
  cell_types: ["myocyte", "satellite cell"]
  culture_protocol: "https://protocols.io/wetware/muscle-culture-v2"
  biosafety_level: "BSL-1"

interface:
  inputs:
    - id: "electrical_stimulation"
      type: "electrical"
      required: true
      parameters:
        voltage: { range: [0, 5], unit: "V" }
        frequency: { range: [1, 100], unit: "Hz" }
        pulse_width: { range: [0.1, 10], unit: "ms" }
      response_time: 50  # ms
    
    - id: "perfusion_input"
      type: "perfusion"
      required: true
      parameters:
        flow_rate: { range: [0.1, 2.0], unit: "mL/min" }
        
  outputs:
    - id: "force_output"
      type: "mechanical"
      parameters:
        force: { range: [0, 50], unit: "mN" }
        displacement: { range: [0, 5], unit: "mm" }
      latency: 150  # ms
      monitoring:
        metrics: ["force", "displacement", "velocity"]
        sampling_rate: 100  # Hz

requirements:
  physical:
    temperature: { optimal: 37, range: [35, 39], unit: "C" }
  chemical:
    pH: { optimal: 7.4, range: [7.2, 7.6] }
    oxygen: { range: [15, 25], unit: "%" }
    glucose: { range: [5, 25], unit: "mM" }

performance:
  functional:
    max_force: { value: 50, unit: "mN" }
    response_time: { typical: 150, max: 300, unit: "ms" }
    contraction_velocity: { max: 10, unit: "mm/s" }
  reliability:
    lifetime: { mean: 14, std: 3, unit: "days" }
    failure_rate: { value: 0.01, unit: "per_hour" }
  resources:
    oxygen_consumption: { value: 5, unit: "umol/hour" }
    glucose_consumption: { value: 2.5, unit: "umol/hour" }

failure_modes:
  - id: "fatigue"
    type: "recoverable"
    probability: 0.3
    detection: "force_output < 80% baseline"
    impact: "reduced_performance"
    mitigation: "reduce stimulation, allow recovery"
  
  - id: "necrosis"
    type: "irreversible"
    probability: 0.05
    detection: "viability < 50%"
    impact: "component_loss"
    mitigation: "replace component"

testing:
  unit_tests:
    - id: "contraction_response"
      description: "Verify force output on stimulation"
      protocol: "stimulate 10Hz 2V for 1s, measure force"
      acceptance: "force in [5, 15] mN within 200ms"
    
    - id: "viability_check"
      description: "Verify cell survival"
      protocol: "live/dead staining"
      acceptance: "viability > 90%"

dependencies:
  adapters:
    - id: "perfusion-adapter"
      version: "^1.0.0"
  protocols:
    - name: "standard-mammalian-culture"
      version: "2.1"
\end{lstlisting}

\section{Bio-Component Spec JSON Schema}
\label{app:schema}

\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
{
  "$schema": "https://wetware-engineering.org/schema/
              bio-component/1.0",
  "type": "object",
  "required": ["bio-component", "info", "classification", 
               "source", "interface"],
  "properties": {
    "bio-component": {
      "type": "string",
      "pattern": "^\\d+\\.\\d+$"
    },
    "info": {
      "type": "object",
      "required": ["id", "name", "version"],
      "properties": {
        "id": {"type": "string", "pattern": "^[a-z0-9-]+$"},
        "name": {"type": "string"},
        "version": {"type": "string", "pattern": "^\\d+\\.\\d+\\.\\d+"},
        "description": {"type": "string"},
        "license": {"type": "string"},
        "authors": {"type": "array", "items": {"type": "string"}},
        "repository": {"type": "string", "format": "uri"}
      }
    },
    "classification": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "enum": ["actuator", "sensor", "processor", 
                   "metabolic", "structural", "connector"]
        },
        "domain": {"type": "string"},
        "tags": {"type": "array", "items": {"type": "string"}}
      }
    },
    "source": {
      "type": "object",
      "properties": {
        "organism": {"type": "string"},
        "tissue_type": {"type": "string"},
        "cell_types": {"type": "array", "items": {"type": "string"}},
        "cell_line": {"type": "string"},
        "genetic_modifications": {"type": "array"},
        "culture_protocol": {"type": "string", "format": "uri"},
        "biosafety_level": {"enum": ["BSL-1", "BSL-2", "BSL-3", "BSL-4"]}
      }
    },
    "interface": {
      "type": "object",
      "properties": {
        "inputs": {"type": "array", "items": {"$ref": "#/defs/Port"}},
        "outputs": {"type": "array", "items": {"$ref": "#/defs/Port"}}
      }
    },
    "requirements": {
      "type": "object",
      "properties": {
        "physical": {"$ref": "#/defs/PhysicalReq"},
        "chemical": {"$ref": "#/defs/ChemicalReq"},
        "biological": {"$ref": "#/defs/BiologicalReq"}
      }
    },
    "performance": {
      "type": "object",
      "properties": {
        "functional": {"type": "object"},
        "reliability": {"type": "object"},
        "resources": {"type": "object"}
      }
    },
    "failure_modes": {
      "type": "array",
      "items": {"$ref": "#/defs/FailureMode"}
    },
    "testing": {
      "type": "object",
      "properties": {
        "unit_tests": {"type": "array"},
        "integration_tests": {"type": "array"}
      }
    },
    "dependencies": {
      "type": "object",
      "properties": {
        "components": {"type": "array"},
        "adapters": {"type": "array"},
        "protocols": {"type": "array"}
      }
    }
  }
}
\end{lstlisting}

\end{document}
